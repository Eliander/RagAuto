%! Author = eliander
%! Date = 24/01/20
%! TEX encoding = UTF-8
%! TEX root = main.tex
\chapter{Analisi del solutore}
\section{L'idea alla base}
Il progetto, fin dall'inizio, è stato pensato diviso in due parti: il solutore ed il parser. Il solutore si occupa di
eseguire l'algoritmo di Chiusura di congruenza mentre il parser si occupa della fase di preprocessing dell'input.
Prima di analizzare il solutore, è necessario soffermarsi sulla struttura base dell'algoritmo
di congruence closure: il \textit{Node}. La classe \texttt{Node.py} definisce il mattone fondamentale
della chiusura di congruenza; i principali elementi della classe sono:
\begin{itemize}
    \item \texttt{int} \textbf{id}: id numerico del nodo
    \item \texttt{String} \textbf{fn}: simbolo della funzione del nodo
    \item \texttt{List<int>} \textbf{args}: id dei nodi argomenti
    \item \texttt{int} \textbf{find}: id del rappresentante della classe a cui appartiene il nodo
    \item \texttt{Set<int>} \textbf{ccpar}: id dei nodi genitori
\end{itemize}
I nodi vengono creati durante la fase di preprocessing dal parser: in questo modo, il solutore
deve preoccuparsi solamente di eseguire la chiusura di congruenza tra gli elementi.
\section{Il solutore}
Il solutore consiste in una classe, \texttt{Graph.py}, contenente i metodi necessari all'implementazione
della chiusura di congruenza. Questa classe è definita dai seguenti attributi:
\begin{itemize}
    \item \texttt{List<Node>} \textbf{DAG}: grafo formato dai nodi del problema
    \item \texttt{Map<int, String>} \textbf{index\_map}: mappa di supporto, utilizzata per ottenere il nome dei nodi dato
                                                        il loro indice
    \item \texttt{List<int>} \textbf{not\_in\_same\_set}: lista proibita, utilizzata per rendere più efficiente il programma
\end{itemize}
I metodi presenti nella classe sono quelli per effettuare la chiusura di congruenza:
\begin{center}
    \label{tab:methods}
    \begin{tabular}{|m{6cm}|m{6cm}|}
        \hline
        \textbf{Metodo} & \textbf{Descrizione} \\ \hline
         \textbf{node}(\texttt{int id}): \texttt{Node n} & Restituisce un nodo dato l'id. \\ \hline
         \textbf{find}(\texttt{int id}): \texttt{int id} & Restituisce il find del nodo: se questo è diverso
                    da se stesso, chiama la funzione \textbf{find} sul nuovo id. \\ \hline
         \textbf{ccpar}(\texttt{int id}): \texttt{Set<int> id} & Restituisce gli id dei nodi genitori del rappresentante
                    della classe. \\ \hline
        \textbf{congruent}(\texttt{int id\_1, int id\_2}): \texttt{boolean result} & Confronta due nodi e restituisce
                    \texttt{true} se sono congruenti (simbolo di funzione ed argomenti uguali),
                    \texttt{false} altrimenti. \\ \hline
        \textbf{union}(\texttt{int id\_1, int id\_2}): \texttt{void} & Unisce due classi di congruenza,
                    accorpando i \textbf{ccpar} di un nodo nell'altro e cambiando il riferimento del \textbf{find} del
                    nodo svuotato verso l'altro nodo. \\ \hline
        \textbf{merge}(\texttt{int id\_1, int id\_2}): \texttt{void} & Metodo che permette di lanciare la \textbf{union}
                    sui termini che devono essere messi nella stessa classe di congruenza. \\ \hline
    \end{tabular}
\end{center}

\section{Euristiche applicate}
Tra le euristiche viste a lezione, ho scelto di implementare la \textit{forbidden list}; questa particolare euristica permette
di far terminare il programma prima dell'esecuzione di tutte le clausole nel caso in cui gli elementi della lista proibita
siano nella stessa classe di congruenza (abbiano quindi lo stesso campo find). Questo controllo viene effettuato dopo ogni
iterazione dell'algoritmo. Un'altra euristica considerata consisteva nell'aggiornamento del campo \textit{find} di tutti gli
elementi appartenenti all'insieme durante l'unione; questa variante è stata scartata in quanto non portava particolari
benefici in termini di tempo anzi, mediamente, allungava l'esecuzione.

